<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Munachar</title>
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-19T08:53:11.130Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>munachar</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Canvas绘图技术</title>
    <link href="http://yoursite.com/2016/07/12/H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94Canvas/"/>
    <id>http://yoursite.com/2016/07/12/H5新特性——Canvas/</id>
    <published>2016-07-11T20:11:29.000Z</published>
    <updated>2016-08-19T08:53:11.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML5新特性——Canvas绘图技术"><a href="#HTML5新特性——Canvas绘图技术" class="headerlink" title="HTML5新特性——Canvas绘图技术"></a>HTML5新特性——Canvas绘图技术</h2><p>提示：Canvas绘图的难点在方法和属性的记忆上！<br>Canvas技术用于在网页上实现绘图，主要应用领域：</p>
<blockquote>
<ul>
<li>绘制各种统计图表，柱状图、饼图、曲线图、分布图…</li>
<li>动画和游戏</li>
</ul>
</blockquote>
<p>  使用Canvas的方法：</p>
<pre><code>&lt;canvas width=&quot;500&quot;  height=&quot;400&quot;&gt;
    您的浏览器不支持Canvas标签！
&lt;/canvas&gt;
</code></pre><a id="more"></a>
<p>提示：</p>
<ol>
<li>Canvas的宽和高只能用属性方式声明！若使用样式来声明则无效。</li>
<li>Canvas的本意是“画布/画板”，可以盛放绘制的内容；真正执行绘图任务的是“画笔/绘图上下文对象”——Context</li>
<li>每一个画布，有且只有一个画笔对象：<pre>
var ctx = canvas.getContext( '2d' );
</pre></li>
<li><p>画笔/绘图上下文对象的成员：<br><pre><br>1.fillStyle:”#000000”            填充颜色<br>2.font:”10px sans-serif”            字体<br>3.globalAlpha:1                    全局透明度<br>4.lineCap:”butt”                    线的端点样式<br>5.lineJoin:”miter”                线的连接处样式<br>6.lineWidth:1                    线条的宽度<br>7.shadowBlur:0                    阴影部分模糊距离<br>8.shadowColor:”rgba(0, 0, 0, 0)”    阴影部分颜色<br>9.shadowOffsetX:0                阴影水平偏移量<br>10.shadowOffsetY:0                阴影竖直偏移量<br>11.strokeStyle:”#000000”            轮廓/描边颜色<br>12.arc:arc()                    绘制一个弧线<br>13.beginPath:beginPath()        开始绘制路径<br>14.clearRect:clearRect()        清除一个矩形范围<br>15.clip:clip()                裁切<br>16.closePath:closePath()        闭合一条路径<br>17.createLinearGradient:createLinearGradient() 创建一个线性渐变色<br>18.createRadialGradient:createRadialGradient() 创建一个径向渐变色<br>19.drawImage:drawImage()        绘制一幅图像<br>20.ellipse:ellipse()            绘制一个椭圆<br>21.fill:fill()                填充一条路径<br>22.fillRect:fillRect()        填充一个矩形区域<br>23.fillText:fillText()        填充一段文本<br>24.lineTo:lineTo()            绘制一条直线<br>25.measureText:measureText()    测量一段文本，得到宽度<br>26.moveTo:moveTo()            移动画笔到指定点<br>27.rect:rect()                绘制一个矩形路径<br>28.rotate:rotate()            旋转<br>29.scale:scale()                缩放<br>30.stroke:stroke()            对一条路径描边<br>31.strokeRect:strokeRect()    对一个矩形进行描边<br>32.strokeText:strokeText()    对一段文本进行描边<br>33.translate:translate()        进行位移<br></pre><br>5.使用画笔在画布上绘制图形<br><br>5.1  绘制矩形(长方形)——矩形以自己的左上角作定位点</p>
<p><pre>ctx.lineWidth = 10;                修改描边的宽度<br>ctx.strokeStyle = ‘颜色’/渐变色;    修改描边的颜色<br>ctx.strokeRect(x, y, w, h)            描边一个矩形<br>ctx.fillStyle = ‘颜色’/渐变色对象;    填充样式<br>ctx.fillRect(x, y, w, h)            填充一个矩形<br>ctx.clearRect(x,y, w, h);            清除一个矩形范围内所有内容<br></pre><br>5.2  绘制文本——文字以自己的坐下角作定位点</p>
<p><pre>ctx.font = ‘20px SimHei’;        设置字体大小和样式<br>var w = ctx.measureText(txt).width;    获取一段文本的宽度<br>ctx.strokeStyle = “颜色”/渐变;<br>ctx.strokeText(txt, x, y)            对文字进行描边<br>ctx.fillStyle = “颜色”/渐变;<br>ctx.fillText(txt, x, y)                对文字进行填充<br></pre><br>5.3  绘制路径</p>
<pre><code>ctx.beginPath( );        //开始一条新路径
</code></pre><p>…在路径上添加定位点…</p>
<pre><code>ctx.closePath( );        //闭合当前路径 
</code></pre><p>路径的两个用途：</p>
<pre><code>(1)ctx.stroke();    //描边刚刚绘制的路径
(2)ctx.fill();        //填充刚刚绘制的路径
</code></pre><p>常见的添加定位点的方法：</p>
<pre><code>ctx.moveTo(x,y);    //把画笔移动到指定点
ctx.lineTo(x,y);        //从上一个点开始到当前点绘制一条直线
ctx.arc(x,y,r,sAngle,eAngle);        //绘制一条圆弧线
ctx.ellipse(x,y,rx,ry,sAngle,eAngle);    //绘制一条椭圆弧线
</code></pre><p>5.4  绘制图像——以图像的左上角为定位点</p>
<pre><code>ctx.rotate( angle );    //旋转画笔，此后绘制的图像/图像都会旋转——旋转围绕着画布的坐标原点为轴
ctx.translate(x, y);    //平移坐标轴的原点
ctx.drawImage(img, x, y);        //原宽原高的绘制图像
ctx.drawImage(img, x, y, width, height);  //使用指定的宽和高绘制图像
</code></pre><p>提示：</p>
<pre><code>1)创建图片： var img =new Image();  img.src=&quot;xx.jpg&quot;;
2)使用图片必须等待加载完成！  img.onload = function(){ ... }        
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML5新特性——Canvas绘图技术&quot;&gt;&lt;a href=&quot;#HTML5新特性——Canvas绘图技术&quot; class=&quot;headerlink&quot; title=&quot;HTML5新特性——Canvas绘图技术&quot;&gt;&lt;/a&gt;HTML5新特性——Canvas绘图技术&lt;/h2&gt;&lt;p&gt;提示：Canvas绘图的难点在方法和属性的记忆上！&lt;br&gt;Canvas技术用于在网页上实现绘图，主要应用领域：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;绘制各种统计图表，柱状图、饼图、曲线图、分布图…&lt;/li&gt;
&lt;li&gt;动画和游戏&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;  使用Canvas的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;canvas width=&amp;quot;500&amp;quot;  height=&amp;quot;400&amp;quot;&amp;gt;
    您的浏览器不支持Canvas标签！
&amp;lt;/canvas&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
      <category term="Canvas" scheme="http://yoursite.com/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>H5新特性——音视频</title>
    <link href="http://yoursite.com/2016/07/11/H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91/"/>
    <id>http://yoursite.com/2016/07/11/H5新特性——视频/</id>
    <published>2016-07-11T14:11:29.000Z</published>
    <updated>2016-08-19T08:25:48.040Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5之前在页面播放需要使用flash播放器；HTML5添加两个标签：</p>
<pre><code>&lt;video&gt;&lt;/video&gt;
&lt;audio&gt;&lt;/audio&gt;
</code></pre><p>这两个标签有一些特殊属性、事件、方法。</p>
<h3 id="HTML5新特性——视频"><a href="#HTML5新特性——视频" class="headerlink" title="HTML5新特性——视频"></a>HTML5新特性——视频</h3><p>1.Video标签可用的属性：</p>
<pre><code>(1)src：待播放的资源的URL
(2)width：播放区域的宽度
(3)height：播放区域的高度
(4)controls：是否显示播放控件，默认不显示
(5)autoplay：是否自动播放，默认不自动播放
(6)loop：是否循环播放，默认不循环
(7)preload：如何预加载视频，可以赋值为
    “none”：不预加载
    “metadata”：只预加载元数据，如影片宽、高、大小、时长
    “auto”：（默认值）自动预加载元数据以及部分影片数据
(8)poster：影片播放之前显示的“电影海报”
</code></pre><a id="more"></a>
<p>2.Video对象的成员</p>
<pre><code>1.autoplay:false
2.controls:false
3.currentTime:0             当前播放到哪一秒
4.duration:NaN            总时长
5.ended:false
6.loop:false            是否循环
7.muted:false            是否静音
8.oncanplay:null            当能够播放时触发
9.oncanplaythrough:null    当能够顺利播放一段时间
10.onended:null            当播放的结尾时触发
11.onerror:null            当播放错误时触发
12.onloadeddata:null        当加载了影片数据时触发
13.onloadedmetadata:null    当加载了影片元数据时触发
14.onpause:null            当影片暂停时触发
15.onplay:null            当影片开始播放时触发
16.paused:true            当前是否处于暂停状态
17.poster:&quot;&quot;                电影海报
18.preload:&quot;auto&quot;            如何预加载
19.src:&quot;http://127.0.0.1/html5_day02/resource/birds.mp4&quot;
20.videoHeight:0
21.videoWidth:0
22.volume:1
23.play(): function(){}    使用JS控制影片播放
24.pause(): function(){}    使用JS控制影片暂停
</code></pre><h3 id="HTML5新特性——音频"><a href="#HTML5新特性——音频" class="headerlink" title="HTML5新特性——音频"></a>HTML5新特性——音频</h3><p>HTML5之前，播放音频可以使用flash播放器，或者使用bgsound（IE专有，只能网页的背景音乐，不能使用JS控制播放、音量）。<br>HTML5中，使用audio标签来播放音频。该标签的常用属性与video几乎一样，如：</p>
<pre><code>(1)src
(2)autoplay：是否自动播放，默认为false
(3)controls：是否显示播放控制条，默认为false
(4)loop：是否循环播放，默认为false
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5之前在页面播放需要使用flash播放器；HTML5添加两个标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;video&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;audio&amp;gt;&amp;lt;/audio&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两个标签有一些特殊属性、事件、方法。&lt;/p&gt;
&lt;h3 id=&quot;HTML5新特性——视频&quot;&gt;&lt;a href=&quot;#HTML5新特性——视频&quot; class=&quot;headerlink&quot; title=&quot;HTML5新特性——视频&quot;&gt;&lt;/a&gt;HTML5新特性——视频&lt;/h3&gt;&lt;p&gt;1.Video标签可用的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)src：待播放的资源的URL
(2)width：播放区域的宽度
(3)height：播放区域的高度
(4)controls：是否显示播放控件，默认不显示
(5)autoplay：是否自动播放，默认不自动播放
(6)loop：是否循环播放，默认不循环
(7)preload：如何预加载视频，可以赋值为
    “none”：不预加载
    “metadata”：只预加载元数据，如影片宽、高、大小、时长
    “auto”：（默认值）自动预加载元数据以及部分影片数据
(8)poster：影片播放之前显示的“电影海报”
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
      <category term="video" scheme="http://yoursite.com/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>H5新特性</title>
    <link href="http://yoursite.com/2016/07/10/H5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/07/10/H5新特性/</id>
    <published>2016-07-10T11:11:29.000Z</published>
    <updated>2016-08-19T08:15:25.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="表单新特性————新的-input-type"><a href="#表单新特性————新的-input-type" class="headerlink" title="表单新特性————新的 input type"></a>表单新特性————新的 input type</h3><pre><code>&lt;input type=&quot;?&quot;&gt;
</code></pre><p>1.1 原有的type: </p>
<pre><code>text、password、radio、checkbox、hidden、file、image、button、submit、reset
</code></pre><p>1.2 新增的type:</p>
<pre><code>email、search、url、tel、number、range、color、date、week、month

1. email:  要求输入必需符合邮箱格式  xx@xx
2. url:  要求输入必需符合URL格式  xx:yy
3. tel:  无输入格式验证，在手机中弹出的数字键盘，而不是字母键盘
4. number: 要求输入一个整型数字，可以配合max/min/step新属性使用
5. search: Chrome中会显示一个x号
6. range: 范围选择器、滑块，可以配合max/min/step新属性使用
7. color：颜色选择器，Chrome/FF偷懒了，都直接使用操作系统自带的颜色选择器
8. date：日期选择器，FF不支持    
9. month：月份选择器，FF不支持
10. week：星期选择器，FF不支持    
</code></pre><a id="more"></a>
<blockquote>
<p>提示：<br>(1) HTML5新添的input type存在严重的兼容性问题！<br>  (2) 新特性弹出的提示消息本质是“窗口”，不是HTML元素，无法使用JS、CSS进行控制！</p>
</blockquote>
<h3 id="表单新特性————新的表单元素"><a href="#表单新特性————新的表单元素" class="headerlink" title="表单新特性————新的表单元素"></a>表单新特性————新的表单元素</h3><p>2.1 原有的表单输入元素：</p>
<pre><code>input、textarea、select/option
</code></pre><p>2.2 新增的表单元素</p>
<pre><code>(1)&lt;datalist&gt;&lt;/datalist&gt;        数据列表，本身是不可见元素，为某个input提供可选输入的列表，使用方法：
    &lt;datalist id=&quot;LISTID&quot;&gt;&lt;option&gt;选项名&lt;/option&gt;&lt;/datalist&gt;
    &lt;input type=&quot;text&quot; list=&quot;LISTID&quot;&gt;

(2)&lt;progress&gt;&lt;/progress&gt;    进度条，仅用于进度的提示，不能被用户操作，也不会被提交。
    &lt;progress value=&quot;0.5&quot;&gt;&lt;/progress&gt;

(3)&lt;meter&gt;&lt;/meter&gt;        刻度尺，仅用于水平/数量的提示，不能被用户操作，也不会被提交。需要指定如下属性：
    &lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; low=&quot;下限值&quot; high=&quot;上限值&quot; optimum=&quot;最优值&quot;  value=&quot;当前实际值&quot;&gt;&lt;/meter&gt;
    如果最优值小于下限值，刻度尺颜色分配：
    min (绿色) low (黄色) high (红色) max
    如果最优值大于下限值且小于上限值，刻度尺颜色分配：
    min (黄色) low (绿色) high (黄色) max
    如果最优值大于上限值，刻度尺颜色分配：
    min (红色) low (黄色) high (绿色) max

(4)&lt;output&gt;&lt;/output&gt;    语义标签，表示一个计算的输出值，仅用于计算结果的提示，不能被用户操作，也不会被提交。
</code></pre><p>提示：上述四个新元素存在兼容性问题。</p>
<h3 id="表单新特性————input的新属性"><a href="#表单新特性————input的新属性" class="headerlink" title="表单新特性————input的新属性"></a>表单新特性————input的新属性</h3><p>3.1 原有的input属性</p>
<pre><code>&lt;input id=&quot;&quot; class=&quot;&quot; style=&quot;&quot; title=&quot;&quot; name=&quot;&quot; value=&quot;&quot; type=&quot;&quot; readonly  checked  selected  diabled &gt;
</code></pre><p>3.2 新增的input属性</p>
<pre><code>&lt;input type=&quot;number&quot; max=&quot;最大值&quot; min=&quot;最小值&quot; step=&quot;步长&quot;&gt;
&lt;input type=&quot;text&quot; list=&quot;datalist元素的ID&quot;  autocomplete=&quot;on/off&quot;&gt;
&lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; low=&quot;下限值&quot; high=&quot;上限值&quot; optimum=&quot;最优值&quot;  value=&quot;当前实际值&quot;&gt;&lt;/meter&gt;

(1)placeholder：占位符，用于在input中显示提示性文字，注意：不是value
(2)autocomplete：可赋值为on或off，是否记录之前提交的内容，以实现下次输入时的自动提示
(3)autofocus：自动获得输入焦点
(4)multiple：用于email/url/tel等，允许使用逗号指定多个输入
(5)form：为input指定form属性，可以将input从form内部提到外部，且不影响输入域的提交
  与表单输入验证有关的属性：
(6)required：必填属性，若用户未填写内容，则无法提交
(7)minlength：限制最少的字符个数，非标准，FF不支持
(8)maxlength：限制最大的字符个数
(9)max：一般用于number、range、&lt;meter&gt;、&lt;progress&gt;，表示允许的数字最大值
(10)min：一般用于number、range、&lt;meter&gt;、&lt;progress&gt;，表示允许的数字最小值
(11)step：一般用于number、range，表示步长
(12)pattern：使用正则表达式进行验证
&lt;input type=&quot;text&quot; name=&quot;cellphone&quot; placeholder=&quot;请输入手机号&quot; pattern=&quot;^1[358]\d{9}$&quot; required&gt;
</code></pre><h3 id="如何修改表单的提示消息"><a href="#如何修改表单的提示消息" class="headerlink" title="如何修改表单的提示消息"></a>如何修改表单的提示消息</h3><p>HTML5表单可能在如下情形下弹出提示消息：<br>(1)特定的input type不被满足，如email、url<br>(2)特定的验证属性不被满足，如required、pattern、step、minlength<br>  不同的浏览器会弹出不同的提示消息。如何自定义弹出的提示消息：<br>  HTML5为所有的表单输入域都添加了一个validity对象属性，该对象中包含如下的属性：</p>
<blockquote>
<p>1.badInput:false            无效的输入，如<br>2.customError:false            是否存在自定义错误<br>3.patternMismatch:false        正则表达式不匹配，违反pattern验证<br>4.rangeOverflow:false        数字范围过大，违反了max验证<br>5.rangeUnderflow:false        数字范围过小，违反了min验证<br>6.stepMismatch:false            步长不匹配，违反step验证<br>7.tooLong:false                字符个数太长，违反maxlength验证<br>8.tooShort:false            字符个数太短，违反minlength验证<br>9.typeMismatch:false            类型不匹配，如email/url格式错误<br>10.valid:true                当前输入值是否有效<br>11.valueMissing:false            缺少值，违反required验证</p>
</blockquote>
<p>上述属性会随着用户的输入即时的发生改变，只要有一项验证失败，对应的boolean值就会变成true，导致valid属性变为false；只有当所有其他属性都变为false，valid属性才会变为true，该输入域是有效的，可以被提交了。<br>通过检查上述属性是否为true，可以通过“设置自定义的有效性消息setCustomValidity”设置自定义的错误消息——validity.customError就会变为true，自定义错误消息的优先级高于浏览器默认的消息优先级。</p>
<pre><code>if( input.validity.xxx === true ){
    input.setCustomValidity(&quot;自定义消息&quot;);
}else {
    input.setCustomValidity(&quot;&quot;);
}    
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;表单新特性————新的-input-type&quot;&gt;&lt;a href=&quot;#表单新特性————新的-input-type&quot; class=&quot;headerlink&quot; title=&quot;表单新特性————新的 input type&quot;&gt;&lt;/a&gt;表单新特性————新的 input type&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;?&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.1 原有的type: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;text、password、radio、checkbox、hidden、file、image、button、submit、reset
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.2 新增的type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;email、search、url、tel、number、range、color、date、week、month

1. email:  要求输入必需符合邮箱格式  xx@xx
2. url:  要求输入必需符合URL格式  xx:yy
3. tel:  无输入格式验证，在手机中弹出的数字键盘，而不是字母键盘
4. number: 要求输入一个整型数字，可以配合max/min/step新属性使用
5. search: Chrome中会显示一个x号
6. range: 范围选择器、滑块，可以配合max/min/step新属性使用
7. color：颜色选择器，Chrome/FF偷懒了，都直接使用操作系统自带的颜色选择器
8. date：日期选择器，FF不支持    
9. month：月份选择器，FF不支持
10. week：星期选择器，FF不支持    
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS hacks的使用</title>
    <link href="http://yoursite.com/2016/07/10/%E5%85%B3%E4%BA%8ECSS%20hack/"/>
    <id>http://yoursite.com/2016/07/10/关于CSS hack/</id>
    <published>2016-07-10T09:01:29.000Z</published>
    <updated>2016-08-25T07:19:47.138Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讨论CSS-hacks，条件引用或者其他。"><a href="#讨论CSS-hacks，条件引用或者其他。" class="headerlink" title="讨论CSS hacks，条件引用或者其他。"></a>讨论CSS hacks，条件引用或者其他。</h4><pre><code>background-color:#f1ee18;/*所有识别*/

background-color:#00deff\9; /*IE6、7、8识别*/

+background-color:#a200ff;/*IE6、7识别*/

_background-color:#1e0bd1;/*IE6识别*/

:root#test{background-color:purple\9;}:root是给ie9的，

@media screen and (-webkit-min-device-pixel-ratio:0){
    .bb{background-color:#f1ee18}/* Safari(Chrome) 有效 */
}{} 
@media all and (min-width: 0px){ 
    .bb{
        background-color:#f1ee18;/*opera and Safari(Chrome) and firefox*/ 
        background-color:#4cac70\0;/* 仅 Opera 有效 */ 
    }
}{} 

.bb, x:-moz-any-link, x:default{
    background-color:#4eff00;/*IE7、Firefox3.5及以下 识别 */
} 
@-moz-document url-prefix(){
    .bb{
        background-color:#4eff00;/*仅 Firefox 识别 */
    }
} 
* +html .bb{background-color:#a200ff;}/* 仅IE7 识别 */&lt;!-- more --&gt;    
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;讨论CSS-hacks，条件引用或者其他。&quot;&gt;&lt;a href=&quot;#讨论CSS-hacks，条件引用或者其他。&quot; class=&quot;headerlink&quot; title=&quot;讨论CSS hacks，条件引用或者其他。&quot;&gt;&lt;/a&gt;讨论CSS hacks，条件引用或者其他。&lt;/
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何共享一个原型对象</title>
    <link href="http://yoursite.com/2016/07/08/%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2016/07/08/如何共享一个原型对象/</id>
    <published>2016-07-08T06:11:29.000Z</published>
    <updated>2016-08-16T07:15:53.136Z</updated>
    
    <content type="html"><![CDATA[<p>我们想创建一个Student构造函数：</p>
<pre><code>function Student(props) {
    this.name = props.name || &apos;Unnamed&apos;;
}
Student.prototype.hello = function () {
    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
}
</code></pre><p>现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p>
<pre><code>function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}
</code></pre><a id="more"></a>    
<p>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null
</code></pre><p>必须想办法把原型链修改为：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre><p>这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。</p>
<p>如果你想用最简单粗暴的方法这么干：</p>
<pre><code>PrimaryStudent.prototype = Student.prototype;
</code></pre><p>是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：</p>
<pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法： (可以省略)
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: &apos;小明&apos;,
    grade: 2
});
xiaoming.name; // &apos;小明&apos;
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
</code></pre><p>注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。</p>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
</code></pre><p>这个inherits()函数可以复用：</p>
<pre><code>function Student(props) {
    this.name = props.name || &apos;Unnamed&apos;;
}

Student.prototype.hello = function () {
    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>JavaScript的原型继承实现方式就是：</li>
<li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</li>
<li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们想创建一个Student构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Student(props) {
    this.name = props.name || &amp;apos;Unnamed&amp;apos;;
}
Student.prototype.hello = function () {
    alert(&amp;apos;Hello, &amp;apos; + this.name + &amp;apos;!&amp;apos;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>常用正则表达式</title>
    <link href="http://yoursite.com/2016/07/06/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/07/06/常用正则表达式/</id>
    <published>2016-07-06T03:11:11.000Z</published>
    <updated>2016-08-16T02:35:04.317Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。</p>
<p>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：</p>
<pre><code>var reg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/; 
var r = fieldValue.match(reg);             
if(r==null)alert(&apos;Date format error!&apos;);
</code></pre><p>下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。</p>
<hr>
<a id="more"></a>
<h3 id="校验密码强度"><a href="#校验密码强度" class="headerlink" title="校验密码强度"></a>校验密码强度</h3><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
</code></pre><h3 id="校验中文"><a href="#校验中文" class="headerlink" title="校验中文"></a>校验中文</h3><p>字符串仅能是中文。</p>
<pre><code>^[\\u4e00-\\u9fa5]{0,}$
</code></pre><h3 id="由数字、26个英文字母或下划线组成的字符串"><a href="#由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="由数字、26个英文字母或下划线组成的字符串"></a>由数字、26个英文字母或下划线组成的字符串</h3><pre><code>^\\w+$
</code></pre><h3 id="校验E-Mail-地址"><a href="#校验E-Mail-地址" class="headerlink" title="校验E-Mail 地址"></a>校验E-Mail 地址</h3><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<pre><code>[\\w!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?
</code></pre><h3 id="校验身份证号码"><a href="#校验身份证号码" class="headerlink" title="校验身份证号码"></a>校验身份证号码</h3><p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$
</code></pre><p>18位：</p>
<pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$
</code></pre><h3 id="校验日期"><a href="#校验日期" class="headerlink" title="校验日期"></a>校验日期</h3><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
</code></pre><h3 id="校验金额"><a href="#校验金额" class="headerlink" title="校验金额"></a>校验金额</h3><p>金额校验，精确到2位小数。</p>
<pre><code>^[0-9]+(.[0-9]{2})?$
</code></pre><h3 id="校验手机号"><a href="#校验手机号" class="headerlink" title="校验手机号"></a>校验手机号</h3><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p>
<pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$
</code></pre><h3 id="判断IE的版本"><a href="#判断IE的版本" class="headerlink" title="判断IE的版本"></a>判断IE的版本</h3><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$
</code></pre><h3 id="校验IP-v4地址"><a href="#校验IP-v4地址" class="headerlink" title="校验IP-v4地址"></a>校验IP-v4地址</h3><p>IP4 正则语句。</p>
<pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
</code></pre><h3 id="校验IP-v6地址"><a href="#校验IP-v6地址" class="headerlink" title="校验IP-v6地址"></a>校验IP-v6地址</h3><p>IP6 正则语句。</p>
<pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
</code></pre><h3 id="检查URL的前缀"><a href="#检查URL的前缀" class="headerlink" title="检查URL的前缀"></a>检查URL的前缀</h3><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//))
{
    s = &apos;http://&apos; + s;
}
</code></pre><h3 id="提取URL链接"><a href="#提取URL链接" class="headerlink" title="提取URL链接"></a>提取URL链接</h3><p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<pre><code>^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?
</code></pre><h3 id="文件路径及扩展名校验"><a href="#文件路径及扩展名校验" class="headerlink" title="文件路径及扩展名校验"></a>文件路径及扩展名校验</h3><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p>
<pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$
</code></pre><h3 id="提取Color-Hex-Codes"><a href="#提取Color-Hex-Codes" class="headerlink" title="提取Color Hex Codes"></a>提取Color Hex Codes</h3><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<pre><code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$
</code></pre><h3 id="提取网页图片"><a href="#提取网页图片" class="headerlink" title="提取网页图片"></a>提取网页图片</h3><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&apos;]{0,1}([^\\&quot;\\&apos;\\ &gt;]*)
</code></pre><h3 id="提取页面超链接"><a href="#提取页面超链接" class="headerlink" title="提取页面超链接"></a>提取页面超链接</h3><p>提取html中的超链接。</p>
<pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;
</code></pre><h3 id="查找CSS属性"><a href="#查找CSS属性" class="headerlink" title="查找CSS属性"></a>查找CSS属性</h3><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p>
<pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}
</code></pre><h3 id="抽取注释"><a href="#抽取注释" class="headerlink" title="抽取注释"></a>抽取注释</h3><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<pre><code>&lt;!--(.*?)--&gt;
</code></pre><h3 id="匹配HTML标签"><a href="#匹配HTML标签" class="headerlink" title="匹配HTML标签"></a>匹配HTML标签</h3><p>通过下面的表达式可以匹配出HTML中的标签属性。</p>
<pre><code>&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\^&apos;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;
</code></pre><p>文／技匠（简书签约作者）<br>原文链接：<a href="http://www.jianshu.com/p/e7bb97218946" target="_blank" rel="external">http://www.jianshu.com/p/e7bb97218946</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。&lt;/p&gt;
&lt;p&gt;正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var reg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/; 
var r = fieldValue.match(reg);             
if(r==null)alert(&amp;apos;Date format error!&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Expression" scheme="http://yoursite.com/tags/Expression/"/>
    
  </entry>
  
  <entry>
    <title>Web前端资源分享</title>
    <link href="http://yoursite.com/2016/07/04/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E7%BD%91/"/>
    <id>http://yoursite.com/2016/07/04/前端资源网/</id>
    <published>2016-07-04T06:11:29.000Z</published>
    <updated>2016-08-15T10:12:18.489Z</updated>
    
    <content type="html"><![CDATA[<p>Web前端资源分享：</p>
<ul>
<li>官方：<ul>
<li>W3C：<a href="http://www.w3.org/" target="_blank" rel="external">http://www.w3.org/</a></li>
<li>ECMA：<a href="http://www.ecmascript.org/" target="_blank" rel="external">http://www.ecmascript.org/</a></li>
<li>Mozilla：<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/</a></li>
</ul>
</li>
<li>微软提供的H5实验室：<br><a href="http://html5labs.interoperabilitybridges.com/" target="_blank" rel="external">http://html5labs.interoperabilitybridges.com/</a><a id="more"></a></li>
<li>第三方国内：<ul>
<li>前端网：<a href="http://www.w3cfuns.com/portal.php" target="_blank" rel="external">http://www.w3cfuns.com/portal.php</a></li>
<li>H5基地：<a href="http://html5.360.cn/" target="_blank" rel="external">http://html5.360.cn/</a></li>
<li>前端里：<a href="http://www.yyyweb.com" target="_blank" rel="external">http://www.yyyweb.com</a></li>
</ul>
</li>
<li>国内各大公司前端团队博客：<ul>
<li>携程：<a href="http://ued.ctrip.com/blog/" target="_blank" rel="external">http://ued.ctrip.com/blog/</a></li>
<li>网易：<a href="http://uedc.163.com" target="_blank" rel="external">http://uedc.163.com</a></li>
<li>腾讯：<ul>
<li><a href="http://isux.tencent.com" target="_blank" rel="external">http://isux.tencent.com</a></li>
<li><a href="http://www.alloyteam.com" target="_blank" rel="external">http://www.alloyteam.com</a></li>
</ul>
</li>
<li>百度：<ul>
<li><a href="http://fex.baidu.com" target="_blank" rel="external">http://fex.baidu.com</a></li>
<li><a href="http://efe.baidu.com" target="_blank" rel="external">http://efe.baidu.com</a></li>
<li><a href="http://mweb.baidu.com" target="_blank" rel="external">http://mweb.baidu.com</a></li>
</ul>
</li>
<li>淘宝：<a href="http://ued.taobao.org/blog/" target="_blank" rel="external">http://ued.taobao.org/blog/</a></li>
<li>360：<a href="http://www.75team.com" target="_blank" rel="external">http://www.75team.com</a></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web前端资源分享：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方：&lt;ul&gt;
&lt;li&gt;W3C：&lt;a href=&quot;http://www.w3.org/&quot;&gt;http://www.w3.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ECMA：&lt;a href=&quot;http://www.ecmascript.org/&quot;&gt;http://www.ecmascript.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mozilla：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/&quot;&gt;https://developer.mozilla.org/zh-CN/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;微软提供的H5实验室：&lt;br&gt;&lt;a href=&quot;http://html5labs.interoperabilitybridges.com/&quot;&gt;http://html5labs.interoperabilitybridges.com/&lt;/a&gt;
    
    </summary>
    
    
      <category term="资源" scheme="http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>不用0，1，2，以及加减乘除来进行运算</title>
    <link href="http://yoursite.com/2016/07/03/%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/07/03/程序运算/</id>
    <published>2016-07-03T08:33:55.000Z</published>
    <updated>2016-08-15T09:56:05.287Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前，有个叫阿隆佐·邱奇，发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号。</p>
<p>JavaScript支持函数，所以可以通过JavaScript用函数来写这些计算。来试试：</p>
<pre><code>&apos;use strict&apos;;
// 定义数字0:
var zero = function (f) {
    return function (x) {
        return x;
    }
};
// 定义数字1:
var one = function (f) {
    return function (x) {
        return f(x);
    }
};
// 定义加法:
function add(n, m) {
    return function (f) {
        return function (x) {
            return m(f)(n(f)(x));
        }
    }
}
// 计算数字2 = 1 + 1:
var two = add(one, one);
// 计算数字3 = 1 + 2:
var three = add(one, two);
// 计算数字5 = 2 + 3:
var five = add(two, three);

// 你说它是3就是3，你说它是5就是5，你怎么证明？
// 给3传一个函数,会打印3次:
(three(function () {
    console.log(&apos;print 3 times&apos;);
}))();

// 给5传一个函数,会打印5次:
(five(function () {
    console.log(&apos;print 5 times&apos;);
}))();
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久很久以前，有个叫阿隆佐·邱奇，发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号。&lt;/p&gt;
&lt;p&gt;JavaScript支持函数，所以可以通过JavaScript用函数来写这些计算。来试试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;a
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>aplly&amp;call方法的使用</title>
    <link href="http://yoursite.com/2016/07/02/aplly&amp;call%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/07/02/aplly&amp;call方法的使用/</id>
    <published>2016-07-02T02:25:02.000Z</published>
    <updated>2016-08-15T09:51:18.048Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在一个对象中绑定函数，称为这个对象的方法。<br>在JavaScript中，对象的定义是这样的：</p>
<pre><code>var xiaoming = {
    name: ‘小明’,
    birth: 1990
};
</code></pre><p>但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：</p>
<pre><code>var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: function () {
    var y = new Date().getFullYear();
        return y - this.birth;
    }
};
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
</code></pre><p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？</p>
<p>在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。<br><a id="more"></a><br>让我们拆开写：</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
r    eturn y - this.birth;
}

var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
</code></pre><p>单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。</p>
<p>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？</p>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。</p>
<p>如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。</p>
<p>坑爹啊！</p>
<p>更坑爹的是，如果这么写：</p>
<pre><code>var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
</code></pre><p>也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！</p>
<p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：</p>
<pre><code>‘use strict’;

var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};
var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined
</code></pre><p>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。</p>
<p>有些时候，喜欢重构的你把方法重构了一下：</p>
<pre><code>‘use strict’;

var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: function () {
    function getAgeFromBirth() {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
    return getAgeFromBirth();
    }
};
xiaoming.age(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined
</code></pre><p>结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）</p>
<p>修复的办法也不是没有，我们用一个that变量首先捕获this：</p>
<pre><code>‘use strict’;

var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};
xiaoming.age(); // 25
</code></pre><p>用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<pre><code>function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
</code></pre><p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<p>Math.max.apply(null, [3, 5, 4]); // 5<br>Math.max.call(null, 3, 5, 4); // 5<br>对普通函数调用，我们通常把this绑定为null。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<pre><code>var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
count += 1;
return oldParseInt.apply(null, arguments); // 调用原函数
};

// 测试:
parseInt(‘10’);
parseInt(‘20’);
parseInt(‘30’);
count; // 3
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h4&gt;&lt;p&gt;在一个对象中绑定函数，称为这个对象的方法。&lt;br&gt;在JavaScript中，对象的定义是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var xiaoming = {
    name: ‘小明’,
    birth: 1990
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var xiaoming = {
    name: ‘小明’,
    birth: 1990,
    age: function () {
    var y = new Date().getFullYear();
        return y - this.birth;
    }
};
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？&lt;/p&gt;
&lt;p&gt;在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。&lt;br&gt;
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动</title>
    <link href="http://yoursite.com/2016/07/01/%E6%B8%85%E6%A5%9A%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2016/07/01/清楚浮动/</id>
    <published>2016-07-01T07:01:28.000Z</published>
    <updated>2016-08-15T09:37:02.416Z</updated>
    
    <content type="html"><![CDATA[<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><pre><code>.order_con:after{
    content: ‘.’;
    display: block;
    visibility: hidden;
    width: 0px;
    height: 0px;
    clear: both;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;清除浮动&quot;&gt;&lt;a href=&quot;#清除浮动&quot; class=&quot;headerlink&quot; title=&quot;清除浮动&quot;&gt;&lt;/a&gt;清除浮动&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;.order_con:after{
    content: ‘.’;
    display: block
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>hexo 常用命令</title>
    <link href="http://yoursite.com/2016/06/28/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/06/28/hexo常用命令/</id>
    <published>2016-06-28T01:01:22.000Z</published>
    <updated>2016-08-15T09:26:50.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用部署步骤"><a href="#常用部署步骤" class="headerlink" title="常用部署步骤"></a>常用部署步骤</h2><blockquote>
<p>每次部署的步骤，可按以下三步来进行。</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre></blockquote>
<h6 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h6><pre><code>hexo new”postName” #新建文章

hexo new page”pageName” #新建页面

hexo generate #生成静态页面至public目录

hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）

hexo deploy #将.deploy目录部署到GitHub

hexo help # 查看帮助

hexo version #查看Hexo的版本
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用部署步骤&quot;&gt;&lt;a href=&quot;#常用部署步骤&quot; class=&quot;headerlink&quot; title=&quot;常用部署步骤&quot;&gt;&lt;/a&gt;常用部署步骤&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每次部署的步骤，可按以下三步来进行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo cl
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>事件冒泡</title>
    <link href="http://yoursite.com/2016/06/25/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    <id>http://yoursite.com/2016/06/25/事件冒泡/</id>
    <published>2016-06-25T12:21:05.000Z</published>
    <updated>2016-08-15T09:21:57.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是JS事件冒泡？"><a href="#什么是JS事件冒泡？" class="headerlink" title="什么是JS事件冒泡？"></a>什么是JS事件冒泡？</h3><p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
<ol>
<li><p>event.stopPropagation();<br>事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转）</p>
</li>
<li><p>return false;<br>事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）</p>
</li>
<li><p>event.preventDefault();<br>如果把它放在头部A标签的click事件中点击“点击我”。<br>会发现它依次弹出：我是最里层—-&gt;我是中间层—-&gt;我是最外层，但最后却没有跳转到百度<br>它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转）</p>
</li>
</ol>
<hr>
<a id="more"></a>
<h3 id="事件周期"><a href="#事件周期" class="headerlink" title="事件周期:"></a>事件周期:</h3><blockquote>
<p>DOM: 3个阶段:</p>
<blockquote>
<ul>
<li>捕获: 由最外层元素向内，逐级记录绑定的事件处理函数，只是记录，而不触发</li>
<li>目标触发: 首先触发实际发生事件的元素上绑定的处理函数（目标元素: 实际发生事件的元素）</li>
<li>冒泡: 由内层向外层依次执行各级绑定的处理函数</li>
</ul>
</blockquote>
<p>鄙视:能否修改事件触发的顺序: ——能！</p>
<pre><code>elem.addEventListener(“事件名”,函数对象,false/true);
</code></pre><p>第三个参数: 是否在捕获阶段提前触发，<br>默认false，只能在冒泡阶段顺序触发<br>改为true，可在捕获阶段提前触发！<br>在捕获阶段提前触发的处理函数，冒泡阶段不会重复触发。<br>IE8: 2个阶段: 没有捕获！——不能修改事件触发的顺序<br>elem.attachEvent(“on事件名”,函数对象)</p>
</blockquote>
<h3 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h3><blockquote>
<p>取消冒泡: 一般用于事件处理函数的末尾</p>
<pre><code>DOM: e.stopPropagation();
IE8: e.cancelBubble=true;
</code></pre><p>兼容: </p>
<pre><code>if(e.stopPropagation!==undefined){
    e.stopPropagation();
}else{
    e.cancelBubble=true;
}
</code></pre><p>利用冒泡:<br>优化: 如果多个平级子元素都绑定了相同的事件处理函数，则只需要在父元素上绑定一次即可。不必反复绑定！<br>为什么: 绑定的事件处理函数越多，页面的执行效率越低。应尽量减少页面中绑定的事件处理函数个数。<br>核心问题：如何获得目标元素:</p>
<pre><code>var target=e.target||e.srcElement
</code></pre></blockquote>
<h3 id="DOM-IE8"><a href="#DOM-IE8" class="headerlink" title="DOM IE8"></a>DOM IE8</h3><blockquote>
<p>取消事件: 在事件处理函数执行过程中，发生了异常或错误，希望事件不再继续触发。<br>如何取消:<br>   js动态绑定事件处理函数: </p>
<pre><code>DOM: e.preventDefault();
IE8: e.returnValue=false;
</code></pre><p>兼容: </p>
<pre><code>if(e.preventDefault!==undefined){
    e.preventDefault();
}else{
    e.returnValue=false;
} 
</code></pre></blockquote>
<p>参考网址：<a href="http://www.jb51.net/article/32792.htm" target="_blank" rel="external">事件冒泡</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是JS事件冒泡？&quot;&gt;&lt;a href=&quot;#什么是JS事件冒泡？&quot; class=&quot;headerlink&quot; title=&quot;什么是JS事件冒泡？&quot;&gt;&lt;/a&gt;什么是JS事件冒泡？&lt;/h3&gt;&lt;p&gt;在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;event.stopPropagation();&lt;br&gt;事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;return false;&lt;br&gt;事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;event.preventDefault();&lt;br&gt;如果把它放在头部A标签的click事件中点击“点击我”。&lt;br&gt;会发现它依次弹出：我是最里层—-&amp;gt;我是中间层—-&amp;gt;我是最外层，但最后却没有跳转到百度&lt;br&gt;它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>模板引擎、字节转换、map函数</title>
    <link href="http://yoursite.com/2016/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2016/06/23/面试题/</id>
    <published>2016-06-23T12:28:10.000Z</published>
    <updated>2016-08-15T08:52:28.605Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-模板引擎"><a href="#1-模板引擎" class="headerlink" title="1. 模板引擎"></a>1. 模板引擎</h5><pre><code>var reg = /\$\{[a-zA-Z]+\}/g;
var tpl = &quot;hello ${who}!&quot;;
var obj = {who:&quot;world&quot;};
function template(tpl,obj){
        var s = reg.exec(tpl);
        var s1 = s[0].slice(2,-1);
        document.write(tpl.replace(reg,obj[s1]));
    }
    //template(tpl,obj);
    template(&apos;Hello,${name}&apos;,{name:&quot;hedahang&quot;});
</code></pre><a id="more"></a>
<h5 id="2-字节转换"><a href="#2-字节转换" class="headerlink" title="2. 字节转换"></a>2. 字节转换</h5><pre><code>&lt;pre&gt;function bytesToSize(bytes) {
    if (bytes === 0) return &apos;0 B&apos;;
    var k = 1024,
            sizes = [&apos;B&apos;, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;, &apos;PB&apos;, &apos;EB&apos;, &apos;ZB&apos;, &apos;YB&apos;],
            i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toPrecision(3) + &apos; &apos; + sizes[i];
}
console.log( bytesToSize(12345));&lt;/pre&gt;
</code></pre><h5 id="3-map函数"><a href="#3-map函数" class="headerlink" title="3. map函数"></a>3. map函数</h5><pre><code>&lt;pre&gt;function map(arr,fun){
    var array = [];
    for(var i = 0;i&lt;arr.length;i++){
        if( i == 0){
            array[i] = fun(0,arr[i]);
        }else{
            array[i] = fun(arr[i-1],arr[i])
        }
    console.log(array);
    }
}
map([1,2,3,4,5],function(o,i){return o + i;})&lt;/pre&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-模板引擎&quot;&gt;&lt;a href=&quot;#1-模板引擎&quot; class=&quot;headerlink&quot; title=&quot;1. 模板引擎&quot;&gt;&lt;/a&gt;1. 模板引擎&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;var reg = /\$\{[a-zA-Z]+\}/g;
var tpl = &amp;quot;hello ${who}!&amp;quot;;
var obj = {who:&amp;quot;world&amp;quot;};
function template(tpl,obj){
        var s = reg.exec(tpl);
        var s1 = s[0].slice(2,-1);
        document.write(tpl.replace(reg,obj[s1]));
    }
    //template(tpl,obj);
    template(&amp;apos;Hello,${name}&amp;apos;,{name:&amp;quot;hedahang&amp;quot;});
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Testing" scheme="http://yoursite.com/categories/Testing/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://yoursite.com/2016/06/23/count%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/06/23/count方法/</id>
    <published>2016-06-23T06:11:29.000Z</published>
    <updated>2016-08-15T08:46:23.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h3><p>封装一个count方法，能实现如此调用：count(a)(b)(c)(d)(e)… 并且返回的值为参数连乘的结果，即abcde*…。如count(1)(3)(7) 得到21</p>
<pre><code>function count(x){
    var fn = function(y){
        return count(x*y);
    }
    fn.toString = function(){
        return x;
    };
    return fn;
};
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;count方法&quot;&gt;&lt;a href=&quot;#count方法&quot; class=&quot;headerlink&quot; title=&quot;count方法&quot;&gt;&lt;/a&gt;count方法&lt;/h3&gt;&lt;p&gt;封装一个count方法，能实现如此调用：count(a)(b)(c)(d)(e)… 并且返回的值为参
    
    </summary>
    
      <category term="Testing" scheme="http://yoursite.com/categories/Testing/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>素数算法</title>
    <link href="http://yoursite.com/2016/06/21/%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/06/21/素数算法/</id>
    <published>2016-06-21T10:50:59.000Z</published>
    <updated>2016-08-15T08:40:45.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="找出数组中的素数"><a href="#找出数组中的素数" class="headerlink" title="找出数组中的素数"></a>找出数组中的素数</h3><p>例如    shu([1,2,5,9,7,8,6,13,56,48,46]) = [2, 5, 7, 13];</p>
<pre><code>function shu(arr){
    return arr.filter(
        function(num) {
          if (num == 1) {
            return false;
          }
          if (num == 2) {
            return true;
          }
          for (var i = 2; i &lt;= Math.sqrt(num); i++) {
            if (num % i == 0) {
              return false;
            }
          }
          return true;
        }
    )
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;找出数组中的素数&quot;&gt;&lt;a href=&quot;#找出数组中的素数&quot; class=&quot;headerlink&quot; title=&quot;找出数组中的素数&quot;&gt;&lt;/a&gt;找出数组中的素数&lt;/h3&gt;&lt;p&gt;例如    shu([1,2,5,9,7,8,6,13,56,48,46]) = [2, 5
    
    </summary>
    
      <category term="Testing" scheme="http://yoursite.com/categories/Testing/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="http://yoursite.com/2016/06/13/next_study/"/>
    <id>http://yoursite.com/2016/06/13/next_study/</id>
    <published>2016-06-13T06:15:33.000Z</published>
    <updated>2016-08-15T09:00:07.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><pre><code>&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt;&gt;Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</p>
<blockquote>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre></blockquote>
<a id="more"></a>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>&gt;&gt; * Red
* Green
* Blue
&gt;&gt; + Tom
+ Jack 
+ Jerry
&gt;&gt; + 张三丰
+ 张翠山
+ 张无忌
&gt; 有序列表 1.
&gt;&gt; 1.  Bird
2.  McHale
3.  Parish

&gt; 1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

&gt;   Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

&gt; 2.  Suspendisse id sem consectetuer libero luctus adipiscing.
1986\. What a great season.
</code></pre><blockquote>
<p>无序列表 *,+,-</p>
<blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Tom</li>
<li>Jack </li>
<li>Jerry</li>
<li>张三丰</li>
<li>张翠山</li>
<li>张无忌<br>有序列表 1.</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</blockquote>
<ol>
<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>
</li>
<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.<br>1986. What a great season.</p>
</li>
</ol>
</blockquote>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>这是一个普通的段落：</p>
<pre><code>这是一个代码区块
&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre><hr>

<p></p><h3>区段元素</h3><p></p>
<blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。<br>不管是哪一种，链接文字都是用 [方括号] 来标记。<br>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>

<pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
</code></pre><p>会产生<br>This is <a href="https://munachar.github.io/404.html" title="Title" target="_blank" rel="external">an example</a> inline link.</p>
<p><a href="http://www.baidu.com/" target="_blank" rel="external">This link</a> has no title attribute.<br>下面是一个参考式链接的范例：</p>
<pre><code>I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].

    [1]: http://google.com/        &quot;Google&quot;
    [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
    [3]: http://search.msn.com/    &quot;MSN Search&quot; 
</code></pre><p>或者：</p>
<pre><code>I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][].

     [google]: http://google.com/        &quot;Google&quot;
     [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
     [msn]:    http://search.msn.com/    &quot;MSN Search&quot;br
</code></pre><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><p>Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;\em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：</strong></p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre><p>效果如下：<br><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：</p>
<pre><code>Use the `printf()` function.
</code></pre><p>效果如下：<br>Use the <code>printf()</code> function.<br>A single backtick in a code span: <code>` </code></p>
<p>A backtick-delimited string in a code span: <code>`&lt;foo&gt;` </code></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre>![Alt text][id]</pre>

<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://example.com/&gt;
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code>&lt;address@example.com&gt;
</code></pre><p>Markdown 会转成：</p>
<pre><code> &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <a href="mailto:address@example.com" target="_blank" rel="external">address@example.com</a>）会变成一个可以点击的「address@example.com」链接。</p>
</blockquote>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<blockquote>
<h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：</em></p>
<pre><code>\*literal asterisks\*
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;引用块&quot;&gt;&lt;a href=&quot;#引用块&quot; class=&quot;headerlink&quot; title=&quot;引用块&quot;&gt;&lt;/a&gt;引用块&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt;&amp;gt;Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; 1.   这是第一行列表项。
&amp;gt; 2.   这是第二行列表项。
&amp;gt; 
&amp;gt; 给出一些例子代码：
&amp;gt; 
&amp;gt;     return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&lt;br&gt;consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;这是第一行列表项。&lt;/li&gt;
&lt;li&gt;这是第二行列表项。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给出一些例子代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>AJAX的XMLHttpRequest对象使用</title>
    <link href="http://yoursite.com/2016/05/20/AJAX%E7%9A%84XMLHttpRequest%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/05/20/AJAX的XMLHttpRequest对象使用/</id>
    <published>2016-05-20T02:09:29.000Z</published>
    <updated>2016-08-15T06:31:53.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><pre><code>   //1 创建XHR对象
    var xhr = null;
    if(window.XMLHttpRequest){  //新IE、其它浏览器
        xhr = new XMLHttpRequest();  
    }else { //老IE
        xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
    }
//2 监听XHR的状态改变
    xhr.onreadystatechange = function(){
      if(xhr.readyState===4){ //DONE响应消息接收完成
        if(xhr.status===200){
          console.log(&apos;响应接收完成且成功&apos;);
          console.log(&apos;响应主体：&apos;+xhr.responseText);
          doResponse(xhr.responseText);//调用自定义的函数，处理响应数据
        }else {
          console.log(&apos;响应接收完成但不成功&apos;);
          console.log(&apos;响应状态码为：&apos;+xhr.status);
        }
      }
    }
</code></pre><a id="more"></a>
<pre><code>//3 打开连接
    xhr.open(&apos;GET&apos;,&apos;test.php?uname=&apos;+n, true);
//4 发送请求消息
    xhr.send( null );
</code></pre></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;代码如下&quot;&gt;&lt;a href=&quot;#代码如下&quot; class=&quot;headerlink&quot; title=&quot;代码如下&quot;&gt;&lt;/a&gt;代码如下&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;   //1 创建XHR对象
    var xhr = null;
    if(window.XMLHttpRequest){  //新IE、其它浏览器
        xhr = new XMLHttpRequest();  
    }else { //老IE
        xhr = new ActiveXObject(&amp;apos;Microsoft.XMLHTTP&amp;apos;);
    }
//2 监听XHR的状态改变
    xhr.onreadystatechange = function(){
      if(xhr.readyState===4){ //DONE响应消息接收完成
        if(xhr.status===200){
          console.log(&amp;apos;响应接收完成且成功&amp;apos;);
          console.log(&amp;apos;响应主体：&amp;apos;+xhr.responseText);
          doResponse(xhr.responseText);//调用自定义的函数，处理响应数据
        }else {
          console.log(&amp;apos;响应接收完成但不成功&amp;apos;);
          console.log(&amp;apos;响应状态码为：&amp;apos;+xhr.status);
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="AJAX" scheme="http://yoursite.com/tags/AJAX/"/>
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>如何处理信息过载</title>
    <link href="http://yoursite.com/2016/05/04/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E6%81%AF%E8%BF%87%E8%BD%BD/"/>
    <id>http://yoursite.com/2016/05/04/如何处理信息过载/</id>
    <published>2016-05-04T06:11:29.000Z</published>
    <updated>2016-08-15T08:41:54.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、俯瞰全景"><a href="#一、俯瞰全景" class="headerlink" title="一、俯瞰全景"></a>一、俯瞰全景</h3><blockquote>
<p>用断舍离的自在力俯瞰信息输入全景<br>微信：群、订阅号、朋友圈<br>微博、日报、新闻等APP<br>书籍、杂志<br>音频<br>其他</p>
</blockquote>
<h3 id="二、正本清源"><a href="#二、正本清源" class="headerlink" title="二、正本清源"></a>二、正本清源</h3><blockquote>
<p>梳理反思，及时清理对你造成困扰的信息源头。<br>以下是我的使用习惯，供参考<br>微信清退规则<br>群：没有群规，且超过一个月不曾发言<br>订阅号：未读数超 30<br>朋友圈：固定时间查阅<br>APP：关掉推送通知，关不掉就卸掉<br><a id="more"></a></p>
<h3 id="三、书籍"><a href="#三、书籍" class="headerlink" title="三、书籍"></a>三、书籍</h3><p>尽量阅读纸质书，不读杂志<br>读「元学科」相关的著作<br>阅读经典与诚意之作<br>阅读器存放的书不超过四本</p>
</blockquote>
<h3 id="四、音频"><a href="#四、音频" class="headerlink" title="四、音频"></a>四、音频</h3><blockquote>
<p>只在通勤时收听</p>
</blockquote>
<h3 id="五、社交"><a href="#五、社交" class="headerlink" title="五、社交"></a>五、社交</h3><blockquote>
<p>远离社交媒体<br>尽可能独立思考地输出代表作<br>有可追溯的记录平台<br>让自己变得优秀，方可与优秀的人相聚</p>
<p>会当凌绝顶，一览众山小。当你攀爬上思想巅峰，你便知，所谓信息过载，便如山边之行云，待一一退去，方可领略真知的雄伟。</p>
</blockquote>
<p>作者：陈素封<br>链接：<a href="http://www.zhihu.com/question/19685050/answer/71453024" target="_blank" rel="external">http://www.zhihu.com/question/19685050/answer/71453024</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、俯瞰全景&quot;&gt;&lt;a href=&quot;#一、俯瞰全景&quot; class=&quot;headerlink&quot; title=&quot;一、俯瞰全景&quot;&gt;&lt;/a&gt;一、俯瞰全景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;用断舍离的自在力俯瞰信息输入全景&lt;br&gt;微信：群、订阅号、朋友圈&lt;br&gt;微博、日报、新闻等APP&lt;br&gt;书籍、杂志&lt;br&gt;音频&lt;br&gt;其他&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二、正本清源&quot;&gt;&lt;a href=&quot;#二、正本清源&quot; class=&quot;headerlink&quot; title=&quot;二、正本清源&quot;&gt;&lt;/a&gt;二、正本清源&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;梳理反思，及时清理对你造成困扰的信息源头。&lt;br&gt;以下是我的使用习惯，供参考&lt;br&gt;微信清退规则&lt;br&gt;群：没有群规，且超过一个月不曾发言&lt;br&gt;订阅号：未读数超 30&lt;br&gt;朋友圈：固定时间查阅&lt;br&gt;APP：关掉推送通知，关不掉就卸掉&lt;br&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>postName</title>
    <link href="http://yoursite.com/2015/08/12/postName/"/>
    <id>http://yoursite.com/2015/08/12/postName/</id>
    <published>2015-08-12T06:11:29.000Z</published>
    <updated>2016-08-15T10:05:14.760Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1. Git安装和Github设置
使用Mac电脑可以直brew安装,

brew install git         #Mac电脑使用brew安装
sudo apt-get install git #Ubuntu系统使用这条命令安装
git操作和github上SSH设置请看这篇博文

使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考官方文档

2. Node.js安装
mac电脑可以直接通过brew安装

#安装命令
brew install node  #如果我没记错的话,最新版的node.js的包中已经集成了npm包管理工具

使用以下命令验证是否安装成功
node -v
npm -v

文／Andrew_liu（简书作者）
原文链接：http://www.jianshu.com/p/858ecf233db9
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;1. Git安装和Github设置
使用Mac电脑可以直brew安装,

brew install git         #Mac电脑使用brew安装
sudo apt-get install git #Ubuntu系统使用这条命令安装
git操作和git
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>postName</title>
    <link href="http://yoursite.com/2015/08/12/H5%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2015/08/12/H5本地缓存和离线缓存/</id>
    <published>2015-08-12T06:11:29.000Z</published>
    <updated>2016-08-26T09:22:49.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、离线缓存"><a href="#一、离线缓存" class="headerlink" title="一、离线缓存"></a>一、离线缓存</h1><p>有一个web应用有三个文件index.html,a.js,b.css，现在需要把js和css文件缓存起来</p>
<p>   1.在index.html里加上<html manifest="test.manifest"></html></p>
<p>   2.manifest清单格式如下<br>    CACHE MANIFEST</p>
<pre><code>#上面一句必须
#v1.0.0
#需要缓存的文件
CACHE:
a.js
b.css
#不需要缓存的文件
NETWORK:
*
#无法访问页面
FALLBACK:
404.html
复制代码
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、离线缓存&quot;&gt;&lt;a href=&quot;#一、离线缓存&quot; class=&quot;headerlink&quot; title=&quot;一、离线缓存&quot;&gt;&lt;/a&gt;一、离线缓存&lt;/h1&gt;&lt;p&gt;有一个web应用有三个文件index.html,a.js,b.css，现在需要把js和css文件缓存起来&lt;/
    
    </summary>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
</feed>
